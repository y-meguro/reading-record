// LICENSE : MIT
"use strict";

var _textlintRuleHelper = require("textlint-rule-helper");

var _matchIndex = require("match-index");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var assert = require("assert");
/*
 全角文字と半角文字の間にスペースを入れるかどうか
 */

var PunctuationRegExp = /[。、]/;
var defaultOptions = {
    // スペースを入れるかどうか
    // "never" or "always"
    space: "never",
    // [。、,.]を例外とするかどうか
    exceptPunctuation: true
};
function reporter(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var Syntax = context.Syntax;
    var RuleError = context.RuleError;
    var report = context.report;
    var fixer = context.fixer;
    var getSource = context.getSource;

    var helper = new _textlintRuleHelper.RuleHelper();
    var spaceOption = options.space || defaultOptions.space;
    var exceptPunctuation = options.exceptPunctuation !== undefined ? options.exceptPunctuation : defaultOptions.exceptPunctuation;
    assert(spaceOption === "always" || spaceOption === "never", "\"space\" options should be \"always\" or \"never\".");
    /**
     * `text`を対象に例外オプションを取り除くfilter関数を返す
     * @param {string} text テスト対象のテキスト全体
     * @param {number} padding +1 or -1
     * @returns {function(*, *)}
     */
    var createFilter = function createFilter(text, padding) {
        /**
         * `exceptPunctuation`で指定された例外を取り除く
         * @param {Object} match
         * @returns {boolean}
         */
        return function (match) {
            var targetChar = text[match.index + padding];
            if (!targetChar) {
                return false;
            }
            if (exceptPunctuation && PunctuationRegExp.test(targetChar)) {
                return false;
            }
            return true;
        };
    };
    // Never: アルファベットと全角の間はスペースを入れない
    var noSpaceBetween = function noSpaceBetween(node, text) {
        var betweenHanAndZen = (0, _matchIndex.matchCaptureGroupAll)(text, /[A-Za-z0-9]([ 　])(?:[、。]|[\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]|[\uD840-\uD87F][\uDC00-\uDFFF]|[ぁ-んァ-ヶ])/);
        var betweenZenAndHan = (0, _matchIndex.matchCaptureGroupAll)(text, /(?:[、。]|[\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]|[\uD840-\uD87F][\uDC00-\uDFFF]|[ぁ-んァ-ヶ])([ 　])[A-Za-z0-9]/);
        var reportMatch = function reportMatch(match) {
            var index = match.index;

            report(node, new RuleError("原則として、全角文字と半角文字の間にスペースを入れません。", {
                index: match.index,
                fix: fixer.replaceTextRange([index, index + 1], "")
            }));
        };
        betweenHanAndZen.filter(createFilter(text, 1)).forEach(reportMatch);
        betweenZenAndHan.filter(createFilter(text, -1)).forEach(reportMatch);
    };

    // Always: アルファベットと全角の間はスペースを入れる
    var needSpaceBetween = function needSpaceBetween(node, text) {
        var betweenHanAndZen = (0, _matchIndex.matchCaptureGroupAll)(text, /([A-Za-z0-9])(?:[、。]|[\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]|[\uD840-\uD87F][\uDC00-\uDFFF]|[ぁ-んァ-ヶ])/);
        var betweenZenAndHan = (0, _matchIndex.matchCaptureGroupAll)(text, /([、。]|[\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]|[\uD840-\uD87F][\uDC00-\uDFFF]|[ぁ-んァ-ヶ])[A-Za-z0-9]/);
        var reportMatch = function reportMatch(match) {
            var index = match.index;

            report(node, new RuleError("原則として、全角文字と半角文字の間にスペースを入れます。", {
                index: match.index,
                fix: fixer.replaceTextRange([index + 1, index + 1], " ")
            }));
        };
        betweenHanAndZen.filter(createFilter(text, 1)).forEach(reportMatch);
        betweenZenAndHan.filter(createFilter(text, 0)).forEach(reportMatch);
    };
    return _defineProperty({}, Syntax.Str, function (node) {
        var isIgnoredParentNode = helper.isChildNode(node, [Syntax.Header, Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis]);
        if (isIgnoredParentNode) {
            return;
        }
        var text = getSource(node);

        if (spaceOption === "always") {
            needSpaceBetween(node, text);
        } else if (spaceOption === "never") {
            noSpaceBetween(node, text);
        }
    });
}
module.exports = {
    linter: reporter,
    fixer: reporter
};
//# sourceMappingURL=index.js.map